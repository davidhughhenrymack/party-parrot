---
description:
globs:
alwaysApply: true
---

Party Parrot is a system that listens to the microphone in realtime, and processes it to make DMX lighting and visuals that respond to dance music.

## Project structure
Use poetry to manage dependencies and to launch commands with `poetry run ...`

Launch tests with `just test`
Launch main app with `just launch`
Add major new features to the `Justfile`


## General
Don't add print statements unless asked
Do not make .txt or .md files unless asked
Do not wrap code in try-except-pass instead make the code work reliably
Avoid uisng `hasattr` instead use concrete typing and None testing. We want our code to be precisely correct, not full of sloppy fallbacks and exception wrappers

## Nodes
If you're working on nodes that inherit from BaseInterpretationNode, read the base class to understand the calling patterns precisely
so that you do not break the intended operation of these classes

## Typing
We use beartype to enforce types.
Decorate classes and lone methods with @beartype. Use unit tests to provide simple testing of this typing.
We want complete type enforcement.

## Testing
Write tests in pytest. Tests should be succint and maintainable. Avoid test sprawl.
Don't test trivial things, test the things that are complicated and need to work properly for the overal system to be good.
New code should have at least some simple useful tests.
If you change code run the associated tests.
If you work on open gl code make sure it passes a headless rendering test.
If you make big changes, run the main program with a timeout to check it runs.
If things break, add test coverage for future.

Embrace writing code that will render the real application (or a portion of it) to a png then
read that png back to test. Keeping main entry flag like "capture to png after 1s" is helpful for this



